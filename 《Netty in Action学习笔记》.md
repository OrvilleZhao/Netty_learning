# 目录* [Netty的核心组件](#Netty的核心组件)* [基于Netty的客户端和服务器](#基于Netty的客户端和服务器)# Netty的核心组件* [Channel](#Channel)* [回调](#回调)* [Future](#Future)* [事件和ChannelHandler](#事件和ChannelHandler)## Channel&emsp;&emsp; Channe1是Java NIO的一个基本构造</br>&emsp;&emsp; 它代表一个到实体(如一个硬件设备、一个文件、一个网络套接字或者一个能够执行一个或者多个不同的I/O操作的程序组件)的开放连接，如读操作和写操作。## 回调&emsp;&emsp; 一个回调其实就是一个方法，一个指向已经被提供给另一个方法的方法的引用。Netty在内部使用了回调;当一个回调被触发时，相关的事件可以被一个实现接口ChannelHandler的类处理。下列的代码就是一个例子，当一个新的连接已经被建立时，ChannelHandler的channelActive()回调方法将会被调用，并将打印出一条信息。```java public class ConnectHandler extends ChannelInboundHandlerAdapter{      @Override      public void channelActive(ChannelHandlerContext ctx)              throws Exception{          System.out.println("Client "+ctx.channel().remoteAddress()+" connected");      } } ```## Future&emsp;&emsp;Future提供了一种在操作完成时通知应用程序的方式。这个对象可以看做是一个异步操作的结果的占位符;它将在未来某时刻完成，并提供对其结果的访问。Netty提供了Future的实现--ChannelFuture，用于在执行异步操作的时候使用。</br>&emsp;&emsp;ChannelFuture提供了几种额外的方法，使得可以注册一个或者多个ChannelFutureListener实例。监听器的回调方法operationComplete()，将会在对应的操作完成以后被调用。然后监听器可以判断该操作是成功还是失败，如果失败可以检索产生的Throwable。</br>&emsp;&emsp;下面代码清单展示了一个ChannelFuture作为一个I/O操作的一部分返回的例子。这里，connect()方法将会直接返回，而不会阻塞，该调用将会在后台完成。```javaChannel channel = ...;ChannelFuture future = channel.connect(new InetSocketAddress("192.168.0.1"，25));//异步的连接到远程节点```&emsp;&emsp;下面代码清单展示了一个ChannelFutureListener。首先，要连接到远程节点上。然后，要注册一个新的ChannelFutureListener到对connect()方法的调用返回的ChannelFuture上。当该监听器被通知连接已经建立的时候，检查对应状态，如果操作成功，则将数据写到该Channel。否则从ChannelFuture中检索对应的Throwable。```javaChannel channel = ...;ChannelFuture future = channel.connect(new InetSocketAddress("192.168.0.1"，25));//异步的连接到远程节点future.addListener(new ChannelFutureListener(){//注册一个ChannelFutureListener，以便在操作完成时获得通知  @Override  public void operationComplete(ChannelFuture future){//检查操作的状态      if(future.isSuccess()){//如果操作成功，则创建一个ByteBuf以持有数据	      ByteBuf buffer = Unpooled.copiedBuffer("Hello"，Charset.defaultCharset);		  ChannelFuture wf = future.channel().writeAndFlush(buffer);//将数据异步的发送到远程节点，返回一个ChannelFuture		  ....	  }else{	      Throwable cause = future.cause();//如果发生错误，则访问描述原因的Throwable		  cause.printStackTrace();	  }  }});```## 事件和ChannelHandler&emsp;&emsp;Netty是一个网络编程框架，所以事件是按照他们与入站或者出站数据流的相关性进行分类的。</br>&emsp;&emsp;可能由入站数据或者相关的状态更改而触发的事件包括：> * 连接已被激活或者连接失活> * 数据读取> * 用户事件> * 错误事件&emsp;&emsp;出站事件时未来将会触发的某个动作的操作结果,这些动作包括：> * 打开或者关闭到远程节点的连接> * 将数据写到或者冲刷到套接字<br>下图展示了一个事件是如何被一个这样的ChannelHandler链处理的:<br><div align="center"><img src="pic//pic1.png"/></div><br>&emsp;&emsp;Netty的ChannelHandler为处理器提供了基本的抽象。Netty提供了大量预定义的可以开箱即用的ChannelHandler实现，包括用于各种协议（如HTTP和SSL/TLS）的ChannelHandler。在内部，ChannelHandler自己也使用事件和Future，使得他们也可以成为应用程序将使用的相同抽象的消费者。# 基于Netty的客户端和服务器* [编写Echo服务器](#编写Echo服务器)* [编写Echo客户端](#编写Echo客户端)## 编写Echo服务器&emsp;&emsp;所有的Netty服务器都需要一下两个部分：> * 至少一个ChannelHandler----该组件实现了服务器对从客户端接收的数据的处理，即它的业务逻辑。> * 引导----这是配置服务器的启动代码。至少，它会将服务器绑定到它要监听连接请求的端口上。### ChannelHandler和业务逻辑&emsp;&emsp;ChannelHandler是一个接口族的父接口，它的实现负责接收并响应事件通知。在Netty应用程序中，所有数据处理逻辑都包含在这些核心抽象的实现中。其中关键点有以下几点* 针对不同类型的事件来调用ChannelHandler；* 应用程序通过实现或扩展ChannelHandler来挂钩到事件的生命周期，并且提供自定义的应用程序逻辑；* 在架构上，ChannelHandler有助于保持业务逻辑与网络处理代码的分离。&emsp;&emsp;由于Echo服务器会响应传入的消息，所以它需要实现ChannelInboundHandler接口，用来定义响应入站事件的方法。ChannelInboundHandlerAdapter类是ChannelInboundHandler的默认实现，因此继承它就可以了。简单的实现如下：```java @Sharable   //标记一个ChannelHandler可以被多个Channel安全地共享 public class EchoServerHandler extends ChannelInboundHandlerAdapter{     //channelRead方法对于每个传入的消息都要调用     @Override	 public void channelRead(ChannelHandlerContext ctx,Object msg){	      ByteBuf in = (ByteBuf)msg;		  System.out.println("Server received: "+in.toString(CharsetUtil.UTF_8));		  ctx.write(in);   //将接收到的消息写给发送者，而不冲刷出站消息	 }	 //通知ChannelInboundHandler最后一次对channelRead()的是当前批量读取中的最后一条消息	 @Override	 public void channelReadComplete(ChannelHandlerContext ctx){	      ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)		       .addListener(ChannelFutureListener.CLOSE);   //将未决消息冲刷到远程节点,而且关闭该Channel	 }	 //在读取操作期间，有异常抛出时会调用	 @Override	 public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause){	     cause.printStackTrace();   //打印异常栈跟踪         ctx.close();		        //关闭该Channel	 } }```**如果不捕获异常:**<br>> &emsp;&emsp;每个Channel都提供了一个与之相关联的ChannelPipeline，其持有一个ChannelHandler的实例链。在默认的情况下，ChannelHandler会把对它的方法调用转发给链中的下一个ChannelHandler。> 因此，如果exceptionCaught()方法没有被该链中的某处实现，那么所接受的异常将会被传递到ChannelPipeline的尾部并被记录。因此应用程序至少应该提供一个实现了exceptionCaught()方法的> ChannelHandler。## 编写Echo客户端