# 目录* [Netty的核心组件](#Netty的核心组件)# Netty的核心组件* [Channel](#Channel)* [回调](#回调)* [Future](#Future)* [事件和ChannelHandler](#事件和ChannelHandler)## Channel&emsp;&emsp; Channe1是Java NIO的一个基本构造</br>&emsp;&emsp; 它代表一个到实体(如一个硬件设备、一个文件、一个网络套接字或者一个能够执行一个或者多个不同的I/O操作的程序组件)的开放连接，如读操作和写操作。## 回调&emsp;&emsp; 一个回调其实就是一个方法，一个指向已经被提供给另一个方法的方法的引用。Netty在内部使用了回调;当一个回调被触发时，相关的事件可以被一个实现接口ChannelHandler的类处理。下列的代码就是一个例子，当一个新的连接已经被建立时，ChannelHandler的channelActive()回调方法将会被调用，并将打印出一条信息。```java public class ConnectHandler extends ChannelInboundHandlerAdapter{      @Override      public void channelActive(ChannelHandlerContext ctx)              throws Exception{          System.out.println("Client "+ctx.channel().remoteAddress()+" connected");      } } ```## Future&emsp;&emsp;Future提供了一种在操作完成时通知应用程序的方式。这个对象可以看做是一个异步操作的结果的占位符;它将在未来某时刻完成，并提供对其结果的访问。Netty提供了Future的实现--ChannelFuture，用于在执行异步操作的时候使用。</br>&emsp;&emsp;ChannelFuture提供了几种额外的方法，使得可以注册一个或者多个ChannelFutureListener实例。监听器的回调方法operationComplete()，将会在对应的操作完成以后被调用。然后监听器可以判断该操作是成功还是失败，如果失败可以检索产生的Throwable。</br>&emsp;&emsp;下面代码清单展示了一个ChannelFuture作为一个I/O操作的一部分返回的例子。这里，connect()方法将会直接返回，而不会阻塞，该调用将会在后台完成。```javaChannel channel = ...;ChannelFuture future = channel.connect(new InetSocketAddress("192.168.0.1"，25));//异步的连接到远程节点```&emsp;&emsp;下面代码清单展示了一个ChannelFutureListener。首先，要连接到远程节点上。然后，要注册一个新的ChannelFutureListener到对connect()方法的调用返回的ChannelFuture上。当该监听器被通知连接已经建立的时候，检查对应状态，如果操作成功，则将数据写到该Channel。否则从ChannelFuture中检索对应的Throwable。```javaChannel channel = ...;ChannelFuture future = channel.connect(new InetSocketAddress("192.168.0.1"，25));//异步的连接到远程节点future.addListener(new ChannelFutureListener(){//注册一个ChannelFutureListener，以便在操作完成时获得通知  @Override  public void operationComplete(ChannelFuture future){//检查操作的状态      if(future.isSuccess()){//如果操作成功，则创建一个ByteBuf以持有数据	      ByteBuf buffer = Unpooled.copiedBuffer("Hello"，Charset.defaultCharset);		  ChannelFuture wf = future.channel().writeAndFlush(buffer);//将数据异步的发送到远程节点，返回一个ChannelFuture		  ....	  }else{	      Throwable cause = future.cause();//如果发生错误，则访问描述原因的Throwable		  cause.printStackTrace();	  }  }});```## 事件和ChannelHandler&emsp;&emsp;Netty是一个网络编程框架,所以事件是按照他们与入站或者出站数据流的相关性进行分类的。</br>&emsp;&emsp;可能由入站数据或者相关的状态更改而触发的事件包括：> * 连接已被激活或者连接失活> * 数据读取> * 用户事件> * 错误事件&emsp;&emsp;出站事件时未来将会触发的某个动作的操作结果,这些动作包括：> * 打开或者关闭到远程节点的连接> * 将数据写到或者冲刷到套接字<br>下图展示了一个事件是如何被一个这样的ChannelHandler链处理的<br><div align="center"><img src="pic//pic1.png"/></div><br>